---
output: github_document
always_allow_html: yes
---
# cytoqc -- A QC tool for openCyto

*cytoqc* performs pre-cleaning, pre-gating and post-gating QC checks.

```{r include=FALSE}
library(knitr)
knitr::opts_chunk$set(warning = FALSE, message = FALSE)
library(kableExtra)
```


```{r}
library(flowCore)
library(flowWorkspace)
# library(cytoqc)
devtools::load_all("../")
```

```{r include=FALSE}
# prepare the test data
data("GvHD")
fs <- GvHD[8:28]#exclude samples that has different Time length
data_dir <- tempfile()
dir.create(data_dir)
write.flowSet(fs, data_dir)
```

## Load the FCS

```{r}
files <- list.files(data_dir, ".fcs", full.names = TRUE)
cqc_data <- cqc_load_fcs(files)
cqc_data
```

```{r include=FALSE}
#simulate channel discrepancy

#case
cf <- cqc_data[[1]]
colnames(cf)[1] <- "fsc-h"

#missing
cqc_data[[1]] <- cf[,1:7]


#redundant
thisfile <- files[2]
fr <- read.FCS(thisfile)
new_col <- exprs(fr)[,8,drop=F]
colnames(new_col) <- "channelA"
fr <- cbind2(fr, new_col)
write.FCS(fr, files[2])
cqc_data[[2]] <- load_cytoframe_from_fcs(thisfile, is_h5 = TRUE)

#typo
cf <- cqc_data[[2]]
colnames(cf)[2] <- "SSC1-H"

#both case and typo
cf <- cqc_data[[3]]
colnames(cf)[1:2] <- c("fsc-h", "SSC1-H")

#order
cf <- cqc_data[[4]]
cf_swap_colnames(cf, "FL1-H", "FL2-H")

```
## Determine the reference channel

```{r}
reference <- cqc_find_reference_channel(cqc_data)
reference
```

## QC check
```{r}
check_results <- cqc_check(reference, cqc_data)
check_results
```


## Recommend the fix 
```{r}
solution <- cqc_find_solution(check_results) 
solution
```

*Show the itemized details*
```{r}
knit_print(solution, itemize = TRUE)
```

## Export/import the `solution` for revision (if needed)
```{r eval=FALSE}
library(readr)
write_csv(solution, csvfile)
#manually edit csvfile and load it back
solution_revised <- read_csv(csvfile)
```

## Apply the fix

```{r}
cqc_fix(solution, cqc_data)
```
## Update QC report
```{r}
check_results <- cqc_check(reference, cqc_data)
check_results
```

## Drop redundant channel
```{r}
cqc_remove_not_in_reference(check_results, cqc_data)
```
     
## Refresh QC report and drop the samples that still can not be fixed
```{r}
check_results <- cqc_check(reference, cqc_data)
check_results
cqc_data <- cqc_drop_samples(cqc_data, check_results)
length(cqc_data)
```

## Similarly the same QC process can be applied for marker
```{r include=FALSE}
#simulate channel discrepancy

cf <- cqc_data[[1]]
cf_rename_marker(cf, "CD15 FITC", "cd15")
cf_rename_marker(cf, "CD33 APC", "apc cd33")


#redundant
cf <- cqc_data[[2]]
markernames(cf) <- c(`FL2-A` = "markerA")

```


```{r}
reference <- cqc_find_reference_marker(cqc_data)
reference
check_results <- cqc_check(reference, cqc_data)
check_results
solution <- cqc_find_solution(check_results, max.distance = 0.4) 
solution
cqc_fix(solution, cqc_data)
check_results <- cqc_check(reference, cqc_data)
check_results
cqc_remove_not_in_reference(check_results, cqc_data)
cqc_check(reference, cqc_data)
```

## QC for panel (i.e. channel + marker)
```{r}
group <- cqc_group_by_panel(cqc_data)
panels <- summary(group)
panels
diff(panels)
```

## Split the data set into separate groups based on their panel settings
```{r}
data_list <- split(group, cqc_data)
data_list
```

## Coerce the cleaned data into `cytoset`
```{r}
cs <- cytoset(data_list[[2]])
cs
```

