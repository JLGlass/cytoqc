

#' Extract channel/marker info from a cytoframe object
#'
#'
#' @return a tibble with two columns: "channel" and 'marker'
#' @importFrom tibble as.tibble
#' @importFrom dplyr select rename
#' @importFrom flowCore parameters
#' @noRd
cf_get_params_tbl <- function(cf){
  pData(parameters(cf)) %>%
    as.tibble() %>%
      select(c("name", "desc")) %>%
        rename(channel = name, marker = desc)

}

#' @export
cqc_group <- function(x, ...)UseMethod("cqc_group")

#' @export
cqc_group.cqc_gs_list <- function(x, ...){
  cflist <- sapply(x, function(gs)get_cytoframe_from_cs(gs_pop_get_data(gs), 1))
  cflist <- cqc_cf_list(cflist)
  res <- cqc_group(cflist, ...)
  class(res) <- c("cqc_group_gs", class(res))

  attr(res, "data") <- x
  res
}
#' QC check
#'
#' This is the first step of the entire qc workflow.
#' It extracts meta information(specified by 'type' argument) from the raw data
#' and compare/group them across samples.
#' This provides a sample-wise data table for the further summary report.
#'
#' @return a tibble with 4 columns: object, qc type (e.g. channel), group_id and nobject (i.e. group count)
#' @param x cqc_cf_list
#' @param type specify the qc type, can be "channel", "marker" or "panel"
#' @param delimiter a special character used to separate channel and marker
#' @examples
#' \dontrun{
#' groups <- cqc_group(cqc_cf_list, "channel")
#' }
#' @export
#' @importFrom dplyr filter arrange pull mutate group_indices distinct count add_count
#' @importFrom tidyr separate separate_rows
cqc_group.cqc_cf_list <- function(x, type = c("channel", "marker", "panel", "keyword"), delimiter = "|"){
  sep <- paste0(delimiter, delimiter)#double delimiter for sep params and single delimiter for sep channel and marker
  keys <- sapply(x, function(cf){
    if(type == "keyword")
    {
      key <- names(keyword(cf, compact = TRUE))
    }else{
      key <- cf_get_params_tbl(cf) #%>% arrange(channel)
      if(type != "channel")
        key <- filter(key, is.na(marker) == FALSE)
      if(type == "panel")
        key <- unite(key, panel, channel, marker, sep = delimiter)
      key <- key[[type]]
    }

      key %>% sort() %>%
      paste(collapse = sep)
  })
  res <- tibble(object = names(keys), key = keys)
  gid <- group_indices(res, key)
  res <- res %>%
    mutate(group_id = gid) %>%
    add_count(group_id, key) %>%
    rename(nObject = n) %>%
    separate_rows(key, sep = paste0("\\Q", sep, "\\E"))
  if(type == "panel")
    res <- separate(res, key, c("channel", "marker"), sep = paste0("\\Q", delimiter, "\\E"))
  else
    res <- rename(res, !!type := key)


  #
  # res <- strsplit(res, split= sep, fixed = "TRUE")[[1]]
  # res <- tibble(reference = res)
  # if(type == "marker")
  #   res <- separate(res, channel, c("channel", "marker"), sep = paste0("\\Q", delimiter, "\\E"))
  class(res) <- c("cqc_group", class(res))
  class(res) <- c(paste0("cqc_group_", type), class(res))
  attr(res, "data") <- x
  res
}

#' Provide the summary view of the qc report
#'
#' It summarise the sample-wise qc report into group overview report for reference selection and further QC action.
#'
#' @param object qc table returned by 'cqc_group'
#' @examples
#' \dontrun{
#' su <- summary(groups)
#'
#' }
#' @export
summary.cqc_group <- function(object){
  res <-  object %>%
    select(-c(object)) %>%
    distinct()
  class(res) <- c("cqc_group_summary", class(res))
  res
}

#' @export
diff.cqc_group_keyword <- function(x){

  diff.cqc_group(x, c("keyword"))
}

#' @export
diff.cqc_group_channel <- function(x){

  diff.cqc_group(x, c("channel"))
}

#' @export
diff.cqc_group_marker <- function(x){

  diff.cqc_group(x, c("marker"))
}
#' @export
diff.cqc_group_panel <- function(x){

  diff.cqc_group(x, c("channel", "marker"))
}

#' Helper function to only show the difference among qc group
#'
#' @param x the grouped summary report generated by 'summary' call on the 'cqc_group' results
#' @examples
#' \dontrun{
#' su <- summary(groups)
#' diff(su)
#'
#' }
#' @importFrom dplyr group_split inner_join anti_join
#' @importFrom purrr reduce map map_dfr
#' @export
diff.cqc_group <- function(x, vars){
  grps <- x %>%
    group_split(group_id)
  commons <- grps %>% reduce(inner_join, by = vars)
  grps %>%
    map_dfr(anti_join, y = commons, by = vars)  %>%
    `class<-`(value = class(x))
}

#' Split the samples into groups
#'
#' It is used to split samples into separate groups when they can't be reconciled into the sampe group.
#'
#' @importFrom purrr walk
#' @export
split.cqc_group <- function(x){
  cqc_data <- attr(x, "data")
  data_type <- class(cqc_data)
  vec <- x %>% select(c(object, group_id)) %>% distinct() %>% pull(group_id)
  split(cqc_data, vec) %>% map(function(i){
    class(i) <- c(data_type, class(i))
    i
  })
}

#' Helper function to remove the outlier groups that can't be fixed
#'
#' @param groups the object returned by 'cqc_groups'
#' @param id the group id to be dropped from the dataset
#' @export
cqc_drop_groups <- function(groups, id){
  cqc_data <- attr(groups, "data")
  data_type <- class(cqc_data)
  torm <- filter(groups, group_id == id) %>% pull(object) %>% unique()
  cqc_data <- cqc_data[-match(torm, names(cqc_data))]
  class(cqc_data) <- data_type
  groups <- filter(groups, group_id != id)
  attr(groups, "data") <- cqc_data
  groups
}

#' Helper function to extract the data from 'cqc_groups' object
#'
#' @param groups the object returned by 'cqc_groups'
#' @param id the group id to be selected from the dataset, default is NULL, meaning all data
#' @export
cqc_get_data <- function(groups, id = NULL){
  cqc_data <- attr(groups, "data")
  if(!is.null(id))
  {
    sel <- filter(groups, group_id == id) %>% pull(object) %>% unique()
    cqc_data <- cqc_data[sel]
  }
  cqc_data
}
#' set reference
#'
#' It is the step prior to the further qc solution finding step.
#'
#' @param x cqc report generated by 'cqc_group'
#' @param ref specifies the reference, which can be either an integer group id or a characte vector giving the actual values of the reference
#' @return the original cqc report with the reference info attached
cqc_set_reference <- function(x, ref){
  .Defunct("cqc_match_reference")
  attr(x, "reference") <- ref
  x
}
