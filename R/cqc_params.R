#' Load FCS files
#' load fcs into 'cqc_data' object which is a list of cytoframes
#' @export
cqc_load_fcs <- function(files, is_h5 = TRUE, ...){
  res <- sapply(files, function(file)load_cytoframe_from_fcs(file, is_h5 = is_h5, ...))
  names(res) <- basename(names(res))
  attr(res, "class") <- "cqc_data"
  res
}

#' Extract channel/marker info from a cytoframe object
#'
#'
#' @return a tibble with two columns: "channel" and 'marker'
#' @importFrom tibble as.tibble
#' @importFrom dplyr select rename
#' @importFrom flowCore parameters
#' @noRd
cf_get_params_tbl <- function(cf){
  pData(parameters(cf)) %>%
    as.tibble() %>%
      select(c("name", "desc")) %>%
        rename(channel = name, marker = desc)

}

#' @export
cqc_check <- function(x, ...)UseMethod("cqc_check")

#' QC check
#'
#' This is the first step of the entire qc workflow.
#' It extracts meta information(specified by 'type' argument) from the raw data
#' and compare/group them across samples.
#' This provides a sample-wise data table for the further summary report.
#'
#' @return a tibble with 4 columns: FCS, qc type (e.g. channel), group_id and nFCS (i.e. group count)
#' @param x cqc_data
#' @param type specify the qc type, can be "channel", "marker" or "panel"
#' @param delimiter a special character used to separate channel and marker
#' @examples
#' \dontrun{
#' groups <- cqc_check(cqc_data, "channel")
#' }
#' @export
#' @importFrom dplyr filter arrange pull mutate group_indices distinct count add_count
#' @importFrom tidyr separate separate_rows
cqc_check.cqc_data <- function(x, type = c("channel", "marker", "panel"), delimiter = "|"){
  sep <- paste0(delimiter, delimiter)#double delimiter for sep params and single delimiter for sep channel and marker
  keys <- sapply(x, function(cf){
    key <- cf_get_params_tbl(cf) #%>% arrange(channel)
    if(type != "channel")
      key <- filter(key, is.na(marker) == FALSE)
    if(type == "panel")
      key <- unite(key, panel, channel, marker, sep = delimiter)

      key[[type]] %>% sort() %>%
      paste(collapse = sep)
  })
  res <- tibble(FCS = names(keys), key = keys)
  gid <- group_indices(res, key)
  res <- res %>%
    mutate(group_id = gid) %>%
    add_count(group_id, key) %>%
    rename(nFCS = n) %>%
    separate_rows(key, sep = paste0("\\Q", sep, "\\E"))
  if(type == "panel")
    res <- separate(res, key, c("channel", "marker"), sep = paste0("\\Q", delimiter, "\\E"))
  else
    res <- rename(res, !!type := key)


  #
  # res <- strsplit(res, split= sep, fixed = "TRUE")[[1]]
  # res <- tibble(reference = res)
  # if(type == "marker")
  #   res <- separate(res, channel, c("channel", "marker"), sep = paste0("\\Q", delimiter, "\\E"))
  class(res) <- c("cqc_group", class(res))
  class(res) <- c(paste0("cqc_group_", type), class(res))
  attr(res, "data") <- x
  res
}

#' Provide the summary view of the qc report
#'
#' It summarise the sample-wise qc report into group overview report for reference selection and further QC action.
#'
#' @param object qc table returned by 'cqc_check'
#' @examples
#' \dontrun{
#' su <- summary(groups)
#'
#' }
#' @export
summary.cqc_group <- function(object){
  res <-  object %>%
    select(-c(FCS)) %>%
    distinct()
  class(res) <- c("cqc_group_summary", class(res))
  res
}

#' @export
diff.cqc_group_channel <- function(x){

  diff.cqc_group(x, c("channel"))
}

#' @export
diff.cqc_group_marker <- function(x){

  diff.cqc_group(x, c("marker"))
}
#' @export
diff.cqc_group_panel <- function(x){

  diff.cqc_group(x, c("channel", "marker"))
}

#' Helper function to only show the difference among qc group
#'
#' @param x the grouped summary report generated by 'summary' call on the 'cqc_check' results
#' @examples
#' \dontrun{
#' su <- summary(groups)
#' diff(su)
#'
#' }
#' @importFrom dplyr group_split inner_join anti_join
#' @importFrom purrr reduce map map_dfr
#' @export
diff.cqc_group <- function(x, vars){
  grps <- x %>%
    group_split(group_id)
  commons <- grps %>% reduce(inner_join, by = vars)
  grps %>%
    map_dfr(anti_join, y = commons, by = vars)  %>%
    `class<-`(value = class(x))
}

#' Split the samples into groups
#'
#' It is used to split samples into separate groups when they can't be reconciled into the sampe group.
#'
#' @importFrom purrr walk
#' @export
split.cqc_group <- function(x){
  cqc_data <- attr(x, "data")
  vec <- x %>% select(c(FCS, group_id)) %>% distinct() %>% pull(group_id)
  split(cqc_data, vec) %>% map(function(i){
    class(i) <- c("cqc_data", class(i))
    i
  })
}

#' set reference
#'
#' It is the step prior to the further qc solution finding step.
#'
#' @param x cqc report generated by 'cqc_check'
#' @param ref specifies the reference, which can be either an integer group id or a characte vector giving the actual values of the reference
#' @return the original cqc report with the reference info attached
cqc_set_reference <- function(x, ref){

  attr(x, "reference") <- ref
  x
}

#' @export
cqc_find_solution.cqc_group <- function(x, max.distance = 0.1, ...){
  check_results <- cqc_check(groups, ...)
  cqc_find_solution(check_results, max.distance = max.distance)
}
#' @export
cqc_check.cqc_group_channel <- function(x, ...){
  res <- cqc_check_params(x, type = "channel", ...)
  class(res) <- c("cqc_report_channel", class(res))
  res
}

#' @export
cqc_check.cqc_group_marker <- function(x, ...){
  res <- cqc_check_params(x, type = "marker", ...)
  class(res) <- c("cqc_report_marker", class(res))
  res
}

#' find the the difference between the reference and target group
#'
#' Only used internally.
#'
#' @param x cqc report returned by set_reference call
#' @param select the group ids selected for processing
#' @param type the qc type (either "channle", "marker")
#' @importFrom dplyr bind_rows group_keys group_by
#' @importFrom purrr set_names
#' @noRd
cqc_check_params <- function(x, select, type, delimiter ="|"){
  sa <- summary(x)
  ref <- attr(x, "ref")
  if(is.numeric(ref))
    ref <- sa %>% filter(group_id %in% ref) %>% pull(type)


  res <- sa %>%
    filter(group_id%in%select) %>%
    group_by(group_id)

  res <- res %>% group_split() %>%
    map(function(df){

                data <- df[[type]]
                unknown <- setdiff(data, ref)
                missing <- setdiff(ref, data)
                if(length(unknown) > 0 || length(missing) > 0)
                {
                  list(unknown = unknown, missing = missing)
                }
                    }
            ) %>% set_names(group_keys(res)[["group_id"]])

  class(res) <- c("cqc_report_params", class(res))
  attr(res, "groups") <- x

  res
}


#' @importFrom dplyr as_tibble
#' @export
as_tibble.cqc_report_params <- function(x){
  map_dfr(x, function(i){

    tibble("Not in reference" = paste(i[["unknown"]], collapse = ",")
           , "Missing channels" = paste(i[["missing"]], collapse = ",")
    )

  }, .id = "group_id")

}

#' @export
cqc_find_solution <- function(x, ...)UseMethod("cqc_find_solution")
#' @export
cqc_find_solution.cqc_report_channel <- function(x, ...){
  res <- cqc_find_solution.cqc_report(x, ...)
  attr(res, "class") <- c("cqc_solution_channel", attr(res, "class"))
  res

}
#' @export
cqc_find_solution.cqc_report_marker <- function(x, ...){
  res <- cqc_find_solution.cqc_report(x, ...)
  attr(res, "class") <- c("cqc_solution_marker", attr(res, "class"))
  res

}

#' Find solution to resolve the discrepancy discovered by cqc_check_params
#'
#' It tries to find the aproximate match(based on 'agrep') between the target and reference as well as the extra redundunt items that can be removed.
#'
#' @return a table (with 'from' and 'to' columns) represents the itemized fix recommendation. When 'to' is 'NA', it means the entry is redundunt and can be removed
#' @examples
#' \dontrun{
#' solution <-  cqc_find_solution(groups, select = c(1, 4))
#' }
#' @param max.distance Maximum distance allowed for a match. See ?agrep
#' @importFrom tibble tibble add_row
#' @export
cqc_find_solution.cqc_report <- function(x, max.distance = 0.1){
  res <- map_dfr(x, function(check_result)
  {
    unknown <- check_result[["unknown"]]
    missing <- check_result[["missing"]]
    df <- tibble(from = character(), to = character())
    #iteratively try to find the aproximate match between two vecs
    while(length(unknown) >0)
    {
      if(length(missing) >0)
      {
        #Levenshtein (edit) distance
        dist_mat <- adist(unknown, missing, ignore.case = TRUE)
        nrows <- nrow(dist_mat)
        ncols <- ncol(dist_mat)
        #pick the best match
        idx <- which.min(dist_mat)
        # browser()
        #get x, y coordinates
        ridx <- idx %% nrows
        if(ridx==0)
          ridx = nrows
        cidx <- ceiling(idx / nrows)
        #get the pair
        from <- unknown[ridx]
        to <- missing[cidx]
        #pop the processed item
        unknown <- unknown[-ridx]
        missing <- missing[-cidx]
        #check if exceeds max.distance
        #agrep can be avoided if the formula of max.distance used by agrep is figured out
        ind <- agrep(from, to, ignore.case = TRUE, max.distance = max.distance)
        if(length(ind) > 0)#
          df <- add_row(df, from = from, to = to)
        else
          next #otherwise stop the matching process
      }else#extra params
      {
        df <- add_row(df, from = unknown, to = NA)
        unknown <- character()
      }
    }
    df
  }, .id = "group_id") %>% mutate(group_id = as.integer(group_id))
  attr(res, "class") <- c("cqc_solution", attr(res, "class"))
  attr(res, "group") <- attr(x, "group")
  res
}


#' @export
cqc_fix <- function(x, ...)UseMethod("cqc_fix")

#' Apply the cqc_solution
#'
#' Peform the actual fixing action (i.e update or delete)
#' @param x the cqc_solution returned by 'find_solution' calls
#'
#' @importFrom dplyr rowwise do
cqc_fix.cqc_solution <- function(x, func){
  group <- attr(x, "group")
  cqc_data <- attr(group, "data")

  invisible(group %>% inner_join(x, "group_id") %>%
   select(FCS, from, to) %>% distinct() %>% rowwise() %>% do({
      cf <- cqc_data[[.[["FCS"]]]]
      if(is.na(.[["to"]]))
      {
        if(is(x, "cqc_solution_channel"))
        {
          cols <- flowWorkspace::colnames(cf)
          j <- which(!cols %in% .[["from"]])
          flowWorkspace:::subset_cytoframe_by_cols(cf@pointer, j - 1)
        }else if(is(x, "cqc_solution_marker"))
        {
          cf_rename_marker(cf, .[["from"]], "")
        }else
          stop("don't know how to proceed!")

      }else
        func(cf, .[["from"]], .[["to"]])
      tibble()
    }))

}
#' @export
cqc_fix.cqc_solution_channel <- function(x){
  cqc_fix.cqc_solution(x, function(cf,...)flowWorkspace:::setChannel(cf@pointer, ...))
}

#' @export
cqc_fix.cqc_solution_marker <- function(x){
  cqc_fix.cqc_solution(x, cf_rename_marker)

}

#' Helper function to remove the outlier groups that can't be fixed
#'
#' @param cqc_groups the object returned by 'cqc_check'
#' @param id the group id to be dropped from the dataset
#' @export
cqc_drop_groups <- function(cqc_groups, id){
  cqc_data <- attr(cqc_groups, "data")
  torm <- filter(cqc_groups, group_id == id) %>% pull(FCS) %>% unique()
  cqc_data <- cqc_data[-match(torm, names(cqc_data))]
  class(cqc_data) <- "cqc_data"
  cqc_data
}



# cqc_get_panel_info <- function(x){
#   delimiter <- attr(x, "delimiter")
#   sep <- paste0(delimiter, delimiter)
#   x %>% count(panel_id, panel) %>%
#       rename(nFCS = n) %>%
#       separate_rows(panel, sep = paste0("\\Q", sep, "\\E")) %>%
#         separate(panel, c("channel", "marker"), sep = paste0("\\Q", delimiter, "\\E"))
# }

#' @export
write_fcs <- function(x, ...)UseMethod("write_fcs")

#' The helper function to write the cleaned cqc_data back to fcs
#' @param x cqc_data
#' @param out the output directory that the FCS will be written
#' @export
write_fcs.cqc_data <- function(x, out, verbose = TRUE){
  if(!dir.exists(out))
    dir.create(out)
  for(sn in names(x))
  {
    if(verbose)
      message("writing ", sn)
    # fr <- cytoframe_to_flowFrame(x[[sn]])
    fr <- x[[sn]]
    write.FCS(fr, filename = file.path(out, sn))
  }

}
