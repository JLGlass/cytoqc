#' find the the difference between the reference and target group
#'
#'
#' @param x \code{cqc_check} result returned by cqc_check call
#' @param ...
#'        ref specifies the reference, which can be either an integer group id or a characte vector giving the actual values of the reference
#'        select the group ids selected for processing
#'        type the qc type (either "channle", "marker", "gate")
#' @export
cqc_match <- function(x, ...) UseMethod("cqc_match")

#' @export
cqc_match.default <- function(x, ...) {
  stop("The input is not a valid 'cqc_check' result!\nPlease make sure to follow the right order of 'cqc_check-->cqc_match-->cqc_fix' workflow!")
}

#' @export
cqc_match.cqc_check_channel <- function(x, ...) {
  res <- match_reference(x, type = "channel", ...)
  res
}

#' @export
cqc_match.cqc_check_marker <- function(x, ...) {
  res <- match_reference(x, type = "marker", ...)
  res
}

#' @export
cqc_match.cqc_check_keyword <- function(x, ...) {
  res <- match_reference(x, type = "keyword", ...)
  res
}
#' @export
cqc_match.cqc_check_gate <- function(x, ...) {
  res <- match_reference(x, type = "gate", ...)
  res
}
#' find the the difference between the reference and target group
#'
#' Only used internally.
#'
#' @param x cqc report returned by set_reference call
#' @param ref specifies the reference, which can be either an integer group id or a characte vector giving the actual values of the reference
#' @param select the group ids selected for processing
#' @param type the qc type (either "channle", "marker")
#' @importFrom dplyr bind_rows group_keys group_by
#' @importFrom purrr set_names
#' @noRd
match_reference <- function(x, ref, select = NULL, type, delimiter = "|", ...) {
  res <- summary(x)#get group-wise check report
  if (is.numeric(ref)) {#fetch reference vector from check result if ref is an id
    refid <- ref
    ref <- res %>%
      filter(group_id %in% ref) %>%
      pull(type)
  }else
    refid <- -1

  if (!is.null(select)) {
    res <- filter(res, group_id %in% select)#select the target groups
  }else
  {
    if(refid>0)
      res <- filter(res, group_id != refid)#exclude the reference group if ref id is supplied

  }
  res <- group_by(res, group_id)

  res <- res %>%
    group_split() %>%#process each group
    map(function(df) {
      data <- df[[type]]#grab the key column
      unknown <- setdiff(data, ref) #find the item that are in the target groups but not in ref
      missing <- setdiff(ref, data) # find the item that are in the ref but not in the other group
      if (length(unknown) > 0 || length(missing) > 0) {
        list(unknown = unknown, missing = missing)
      }
    }) %>%
    set_names(group_keys(res)[["group_id"]])

  class(res) <- c(paste0("cqc_match_result_", type), "cqc_match_result", class(res))

  attr(res, "groups") <- x
  #perform the auto matching between the unknown and missing entries
  solution <- cqc_recommend(res, ...)

  res <- list(solution = solution, match_result = res, ref = ref)
  class(res) <- c("cqc_match_result_and_solution", class(res))
  res
}

#' Manual update the match report
#'
#' There are cases where the automatic string match from `cqc_match` can't resolve.
#' This function provides the remedy to manually update the match result.
#'
#' @param x 'cqc_match_result_and_solution' object generated by "cqc_match"
#' @param group_id the group to update. If NULL, then operate on all groups
#' @param map a named vector that provides the paired the strings(i.e. old value vs new value)
#' @export
cqc_update_match <- function(x, map, group_id = NULL){
  if(!is(x, "cqc_match_result_and_solution"))
    stop("x must be the match result generated by cqc_match call!")
  match_res <- x$match_result
  grp.attr <- attr(x$solution, "group")
  cls <- class(x$solution)
  #if groupid is not given then apply to all groups
  if(is.null(group_id))
  {
    group_id <- names(match_res)
  }
  #loop through each group
  new_solution <- map_dfr(group_id, function(gid){
    from <- names(map)#grab the src from new input
    #make sure the new input was listed as one of unmatched items
    unknown <- match_res[[gid]][["unknown"]]
    from <- from[from %in% unknown]
    #add the new pair into solution
    tibble(group_id = as.integer(gid), from = from, to = map[from])
  })
  #append the new solution to the existing one
  x$solution <- bind_rows(x$solution, new_solution)
  #restore attr
  attr(x$solution, "group") <- grp.attr
  class(x$solution) <- cls
  x
}

#' Convert the match_result to table
#' @param x "cqc_match_result" returned as part of cqc_match call
#' @importFrom dplyr as_tibble
#' @export
as_tibble.cqc_match_result <- function(x) {
  map_dfr(x, function(i) {
    tibble(
      "Not in reference" = paste(i[["unknown"]], collapse = ","),
      "Missing channels" = paste(i[["missing"]], collapse = ",")
    )
  }, .id = "group_id")
}
