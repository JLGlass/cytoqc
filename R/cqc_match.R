#' find the the difference between the reference and target group
#'
#'
#' @param x \code{cqc_check} result returned by cqc_check call
#' @param ...
#'
#'        ref -- specifies the reference, which can be either an integer group id or a character vector giving the actual values of the reference
#'
#'        select -- the group ids selected for processing
#'
#'        type -- the qc type (either "channel", "marker", "gate"), automatically determined by the type of \code{x}
#'        
#'        max.distance -- Maximum distance allowed for a match. See ?agrep
#'        
#'        partial whether -- to do the partial sub string matching before the approximate string matching
#'
#' @examples 
#' fcs_files <- list.files(system.file("extdata", "GvHD_QC", package = "cytoqc"), full.names = TRUE)
#' qc_cf_list <- cqc_load_fcs(fcs_files)
#' channel_groups <- cqc_check(qc_cf_list, type = "channel")
#' summary(channel_groups)
#' channel_match <- cqc_match(channel_groups, 3)
#' channel_match
#' @export
cqc_match <- function(x, ...) UseMethod("cqc_match")

#' @export
cqc_match.default <- function(x, ...) {
  stop("The input is not a valid 'cqc_check' result!\nPlease make sure to follow the right order of 'cqc_check-->cqc_match-->cqc_fix' workflow!")
}

#' @export
cqc_match.cqc_check_channel <- function(x, ...) {
  res <- match_reference(x, type = "channel", ...)
  res
}

#' @export
cqc_match.cqc_check_marker <- function(x, ...) {
  res <- match_reference(x, type = "marker", ...)
  res
}

#' @export
cqc_match.cqc_check_keyword <- function(x, ...) {
  res <- match_reference(x, type = "keyword", ...)
  res
}
#' @export
cqc_match.cqc_check_gate <- function(x, ...) {
  res <- match_reference(x, type = "gate", ...)
  res
}

#' @export
#' @importFrom dplyr group_walk
cqc_match.cqc_check_panel <- function(x, ref, ...) {
  by <- attr(x, "by")
  #check if anchor is already standardized
  stopifnot(is(ref, "numeric"))
  ref_by <- filter(x, group_id == ref)[[by]]
  x %>% filter(group_id != ref) %>%
    group_by(group_id) %>% group_walk(function(df,...){
      if(!setequal(df[[by]], ref_by))
        stop(by, " is not consistent across panel groups!Please standardize it first!")
    })
  #simply store the ref and by(or anchor)
  #the actual matching(or alignment) is done in format method
  attr(x, "ref") <- ref
  attr(x, "by") <- by
  class(x) <- c("cqc_match_result_panel", "cqc_match_result", class(x))
  x
}
summary.cqc_match_result_panel <- function(object, ...) {
  cls <- class(object)[1:2]
  class(object) <- class(object)[-c(1:2)]
  x <- summary.cqc_check(object, ...)
  x
}
#' find the the difference between the reference and target group
#'
#' Only used internally.
#'
#' @param x cqc report returned by set_reference call
#' @param ref specifies the reference, which can be either an integer group id or a characte vector giving the actual values of the reference
#' @param select the group ids selected for processing
#' @param type the qc type (either "channle", "marker")
#' @importFrom dplyr bind_rows group_keys group_by
#' @importFrom purrr set_names
#' @noRd
match_reference <- function(x, ref, select = NULL, type, delimiter = "|", ...) {
  res <- summary(x)#get group-wise check report
  if (is.numeric(ref)) {#fetch reference vector from check result if ref is an id
    refid <- ref
    ref <- res %>%
      filter(group_id %in% ref) %>%
      pull(type)
  }else
    refid <- -1

  if (!is.null(select)) {
    res <- filter(res, group_id %in% select)#select the target groups
  }else
  {
    if(refid>0)
      res <- filter(res, group_id != refid)#exclude the reference group if ref id is supplied

  }
  res <- group_by(res, group_id)

  res <- res %>%
    group_split() %>%#process each group
    map(function(df) {
      data <- df[[type]]#grab the key column
      if(length(data) == 1 && data == "")
        data <- character()
      unknown <- setdiff(data, ref) #find the item that are in the target groups but not in ref
      missing <- setdiff(ref, data) # find the item that are in the ref but not in the other group
      if (length(unknown) > 0 || length(missing) > 0) {
        list(unknown = unknown, missing = missing)
      }
    }) %>%
    set_names(group_keys(res)[["group_id"]])

  class(res) <- c(paste0("cqc_match_result_", type), "cqc_match_result", class(res))

  attr(res, "groups") <- x
  #perform the auto matching between the unknown and missing entries
  solution <- cqc_recommend(res, ...)

  res <- list(solution = solution, match_result = res, ref = ref)
  class(res) <- c("cqc_match_result_and_solution", class(res))
  res
}

#' Manual update/delete the match report
#'
#' There are cases where the automatic string match from `cqc_match` can't resolve.
#' This function provides the remedy to manually update the match result.
#'
#' @param x 'cqc_match_result_and_solution' object generated by "cqc_match"
#' @param group_id the group to update. If NULL, then operate on all groups
#' @param map For update, it is a named vector that provides the paired the strings(i.e. old value vs new value)
#'            for deletion, it is a character vector that provides the items to be deleted from matched pairs
#' @examples
#' \dontrun{
#' groups <- cqc_check(cqc_data, "marker")
#' match_result <- cqc_match(groups, ref = 3)
#' #add the matching pairs to the auto-matching results
#' match_result <- cqc_update_match(match_result,  map = c("CD197" = "CCR7"), group_id = 1)
#' #or ommit group_id to apply to all groups
#' match_result <- cqc_update_match(match_result,  map = c("CD197" = "CCR7"))
#' #to delete
#' match_result <- cqc_delete_match(match_result,  "CD197")
#' }
#' @export
#' @rdname cqc_update_match
cqc_update_match <- function(x, map, group_id = NULL){
  if(!is(x, "cqc_match_result_and_solution"))
    stop("x must be the match result generated by cqc_match call!")
  if(length(names(map)) == 0)
    stop("'map' should be named character!")
  match_res <- x$match_result
  grp.attr <- attr(x$solution, "group")
  cls <- class(x$solution)
  type <- sub("cqc_solution_", "", cls[1])
  #if groupid is not given then apply to all groups
  if(is.null(group_id))
  {
    group_id <- names(match_res)
  }
  from <- names(map)#grab the src from new input

  #loop through each group
  new_solution <- map_dfr(group_id, function(gid){
    this_match_res <- match_res[[gid]]
    keys <- filter(grp.attr, group_id == gid)[[type]]
    thisgrp <- filter(x$solution, group_id == gid)
    existing.from <- thisgrp[["from"]]
    existing.to <- filter(thisgrp, !is.na(to))[["to"]]

    #validity check from
    idx <- from %in% x$ref
    if(any(idx))
      stop(paste(from[idx], collapse = ", "), " are references!Something is wrong with the 'map'! ")

    idx <- from %in% existing.from
    if(any(idx))
    {
      print(filter(thisgrp, from %in% !!from))
      stop("Found the existing match. Please call 'cqc_delete_match' to clear the existing match first")
    }
    #only add the entries that are in unknown list
    idx <- from %in% this_match_res[["unknown"]]
    from <- from[idx]
    to <- map[from]

    #validity check for to
    idx <- to %in% x$ref
    if(any(!idx))
      stop(paste(to[!idx], collapse = ", "), " are not valid references!")
    idx <- to %in% existing.to
    if(any(idx))
    {
      print(filter(thisgrp, to %in% !!to))
      stop("Found the existing match. Please call 'cqc_delete_match' to clear the existing match first")
    }
    idx <- to %in% match_res[[gid]][["missing"]]
    if(any(!idx))
      stop(paste(to[!idx], collapse = ", "), " are already perfectly matched!")

    #add the new pair into solution
    tibble(group_id = as.integer(gid), from = from, to = to)
  })
  if(nrow(new_solution)==0)
    stop(paste(from, collapse = ", "), " not found!")
  #append the new solution to the existing one
  x$solution <- bind_rows(x$solution, new_solution)
  #restore attr
  attr(x$solution, "group") <- grp.attr
  class(x$solution) <- cls
  x
}

#' @export
#' @rdname cqc_update_match
cqc_delete_match <- function(x, map, group_id = NULL){
  if(!is(x, "cqc_match_result_and_solution"))
    stop("x must be the match result generated by cqc_match call!")
  if(length(names(map)) > 0)
    stop("'map' should be unnamed character!")
  match_res <- x$match_result
  grp.attr <- attr(x$solution, "group")
  cls <- class(x$solution)

  exclude <- filter(x$solution, from %in% map)
  if(!is.null(group_id))
  {
    exclude <- filter(exclude, group_id %in% group_id)
  }
  if(nrow(exclude) > 0)
  {
    x$solution <- anti_join(x$solution, exclude, by = c("group_id", "from"))
    #restore attr
    attr(x$solution, "group") <- grp.attr
    class(x$solution) <- cls
  }else
    stop("No existing matches for ", paste(map, collapse = ", "), " to delete!")
  x
}
#' #' Convert the match_result to table
#' #' @param x "cqc_match_result" returned as part of cqc_match call
#' #' @importFrom dplyr as_tibble
#' #' @export
#' as_tibble.cqc_match_result <- function(x, ...) {
#'   map_dfr(x, function(i) {
#'     tibble(
#'       "Not in reference" = paste(i[["unknown"]], collapse = ","),
#'       "Missing channels" = paste(i[["missing"]], collapse = ",")
#'     )
#'   }, .id = "group_id")
#' }
