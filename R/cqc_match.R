#' find the the difference between the reference and target group
#'
#'
#' @param x cqc_check object returned by cqc_check call
#' @param ...
#'        ref specifies the reference, which can be either an integer group id or a characte vector giving the actual values of the reference
#'        select the group ids selected for processing
#'        type the qc type (either "channle", "marker", "gate")
#' @export
cqc_match <- function(x, ...) UseMethod("cqc_match")

#' @export
cqc_match.cqc_check_channel <- function(x, ...) {
  res <- match_reference(x, type = "channel", ...)
  res
}

#' @export
cqc_match.cqc_check_marker <- function(x, ...) {
  res <- match_reference(x, type = "marker", ...)
  res
}

#' @export
cqc_match.cqc_check_keyword <- function(x, ...) {
  res <- match_reference(x, type = "keyword", ...)
  res
}
#' @export
cqc_match.cqc_check_gate <- function(x, ...) {
  res <- match_reference(x, type = "gate", ...)
  res
}
#' find the the difference between the reference and target group
#'
#' Only used internally.
#'
#' @param x cqc report returned by set_reference call
#' @param ref specifies the reference, which can be either an integer group id or a characte vector giving the actual values of the reference
#' @param select the group ids selected for processing
#' @param type the qc type (either "channle", "marker")
#' @importFrom dplyr bind_rows group_keys group_by
#' @importFrom purrr set_names
#' @noRd
match_reference <- function(x, ref, select = NULL, type, delimiter = "|", ...) {
  res <- summary(x)
  if (is.numeric(ref)) {
    refid <- ref
    ref <- res %>%
      filter(group_id %in% ref) %>%
      pull(type)
  }else
    refid <- -1

  if (!is.null(select)) {
    res <- filter(res, group_id %in% select)
  }else
  {
    if(refid>0)
      res <- filter(res, group_id != refid)

  }
  res <- group_by(res, group_id)

  res <- res %>%
    group_split() %>%
    map(function(df) {
      data <- df[[type]]
      unknown <- setdiff(data, ref)
      missing <- setdiff(ref, data)
      if (length(unknown) > 0 || length(missing) > 0) {
        list(unknown = unknown, missing = missing)
      }
    }) %>%
    set_names(group_keys(res)[["group_id"]])

  class(res) <- c(paste0("cqc_match_result_", type), "cqc_match_result", class(res))

  attr(res, "groups") <- x

  solution <- cqc_recommend(res, ...)

  res <- list(solution = solution, match_result = res, ref = ref)
  class(res) <- c("cqc_match_result_and_solution", class(res))
  res
}

#' Manual update the match report
#'
#' There are cases where the automatic string match from `cqc_match` can't resolve.
#' This function provides the remedy to manually update the match result.
#'
#' @param x 'cqc_match_result_and_solution' object generated by "cqc_match"
#' @param group_id the group to update. If NULL, then operate on all groups
#' @param map a named vector that provides the paired the strings(i.e. old value vs new value)
#' @export
cqc_update_match <- function(x, group_id = NULL, map){
  if(!is(x, "cqc_match_result_and_solution"))
    stop("x must be the match result generated by cqc_match call!")
  match_res <- x$match_result
  grp.attr <- attr(x$solution, "group")
  cls <- class(x$solution)
  if(is.null(group_id))
  {
    group_id <- as.integer(names(match_res))
  }
  new_solution <- map_dfr(group_id, function(gid){
    tibble(group_id = gid, from = names(map), to = map)
  })

  x$solution <- bind_rows(x$solution, new_solution)
  #restore attr
  attr(x$solution, "group") <- grp.attr
  class(x$solution) <- cls
  x
}
#' @importFrom dplyr as_tibble
#' @export
as_tibble.cqc_match_result <- function(x) {
  map_dfr(x, function(i) {
    tibble(
      "Not in reference" = paste(i[["unknown"]], collapse = ","),
      "Missing channels" = paste(i[["missing"]], collapse = ",")
    )
  }, .id = "group_id")
}
